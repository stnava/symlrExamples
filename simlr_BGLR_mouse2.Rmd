---
title: "SiMLR: BGLR data"
output: html_document
---

see [https://cran.r-project.org/web/packages/BGLR/BGLR.pdf](https://cran.r-project.org/web/packages/BGLR/BGLR.pdf) and [https://cran.r-project.org/web/packages/BGLR/vignettes/BGLR-extdoc.pdf](https://cran.r-project.org/web/packages/BGLR/vignettes/BGLR-extdoc.pdf)


```{r setup}
library( randomForestExplainer )
library( rtemis )
library( ANTsR )
library( ggplot2 )
library( gaston ) # for LD and LD.plot
if ( ! exists( "energyType" ) ) energyType = 'cca'
rf<-usePkg('randomForest')
bg<-usePkg('BGLR')
mlFun <- lm
mlFun <- randomForest
data(mice)
snps<-mice.X
if ( ! exists( "myld" ) )
  myld = LD(as.bed.matrix( snps ), lim=c(1,ncol(snps)) ) # expensive to compute
nfolds<-8
set.seed( 1 )
train <- caret::createDataPartition( mice.pheno[,"Obesity.BMI"], p=0.8)$Resample1
nms = c( "Obesity.BMI"      ,  "Obesity.BodyLength", "EndNormalBW", "GENDER"  )
numericalpheno<-data.matrix( mice.pheno[ , nms ] )
numericalpheno[,"GENDER"] = numericalpheno[,"GENDER"] - 1
temp = data.frame( vox = rnorm( length(train)), mice.pheno[train,nms ] )
temp = lm( vox ~ ( Obesity.BMI  + EndNormalBW + Obesity.BodyLength ) * GENDER, data=temp )
mdlMat = (model.matrix( temp ))[,-1]
snpsf = snps # quantifySNPs( snps ) # convert to frequency
inmats = list(
  as.matrix(snpsf[train,]),
  mdlMat )
BMINAME="Obesity.BMI"
# pheatmap::pheatmap( snps[1:200,1:40], cluster_rows=F, cluster_cols=F, show_rownames = F )
pheatmap::pheatmap( mdlMat[1:200,], cluster_rows=F, cluster_cols=F, show_rownames = F )
```

```{r sym}
# same thing with SiMLR
regs = list()
# demonstrate use of regularization of the high-dimensional matrix
regs[[1]] = as.matrix( myld ) # diag(ncol(inmats[[1]]))
corThresh = c(0.90,0.50)
regs[[1]][regs[[1]]<corThresh[1]]=0
regs[[1]] = as( regs[[1]], "sparseMatrix" )
# regs = regularizeSimlr( inmats, c( 55, 1 ), sigma = c( 10, 10 ) )
regs[[2]] = cor(inmats[[2]])
regs[[2]][regs[[2]]<corThresh[2]]=0
regs[[2]] = as( regs[[2]], "sparseMatrix" )
# library( plot.matrix )
# image( regs[[2]], main='Regularization matrix for supervising variables related to BMI and gender.')
# image( regs[[1]][1:250,1:250], main='Corner of regularization matrix for SNPs.')
bestVarx = 0
nEmbed = 3
mysq = c( 0.95, 0.5 )
if ( ! exists( "snpd" ) )
  snpsvd = prcomp( inmats[[1]], rank. = nEmbed )
for ( k in 1:5 ) { # take best result over multiple initial starting points
  temp = simlr(
    inmats,
    regs,
    iterations = 100,
    sparsenessQuantiles = mysq,
    initialUMatrix = snpsvd$x,
    energyType = energyType,
    verbose = TRUE,
    constraint = c( "Grassmann" ), # some effort to keep V orthogonal
    randomSeed = k-1 )
  svx = predictSimlr( inmats, temp )
  print( svx$varx )
  if ( sum( svx$varx ) > bestVarx ) {
    sResult = temp
    bestVarx = sum( svx$varx )
    }
  }
svx = predictSimlr( inmats, sResult )

# ||<o>||<o>||<o>||<o>||<o>||<o>||<o>||<o>||<o>||
```

Demonstrate post-hoc descriptive statistics and prediction of BMI
from SNPs.

```{r postsym}
print( svx[1] )
# layout( matrix( 1:4, nrow=1 ))
plot( ts( sResult$totalEnergy ) )
straindf<-data.frame( bmi=numericalpheno[ train,BMINAME] , G=numericalpheno[ train,"GENDER"],
   snpse=as.matrix( snpsf[train, ] ) %*% as.matrix( sResult$v[[1]] )/norm( sResult$v[[1]],"F") )
stestdf <-data.frame( bmi=numericalpheno[-train,BMINAME] , G=numericalpheno[ -train,"GENDER"],
   snpse=as.matrix( snpsf[-train,] ) %*% as.matrix( sResult$v[[1]] )/norm( sResult$v[[1]],"F")  )
myrf<-mlFun( bmi ~ . , data=straindf[,], localImp = TRUE )
predictedBMI <- predict( myrf, newdata=stestdf )
print( cor.test( predictedBMI, stestdf$bmi ) )
print(paste( "Err",  mean( abs( predictedBMI-stestdf$bmi ) ) ) )
# plot( predictedBMI, stestdf$bmi ) #  xlim=c(-8,8),ylim=c(-8,8))
rtemis::mplot3.xy(stestdf$bmi, predictedBMI, fit = "lm",main=paste('Predicted vs real BMI'))
importance_frame <- measure_importance( myrf )
plot_multi_way_importance( importance_frame, size_measure = "p_value" )
#  x_measure = "mse_increase",
#  y_measure = "no_of_nodes",
```

LD for the selected SNPs.

```{r myLD}

wvec = abs( sResult$v[[1]][,3] )
wvecTh = quantile( wvec, 0.9995 )
selector = wvec > wvecTh
mySelected = rownames( sResult$v[[1]] )[ selector ]
www = which( selector )
subsnps = snps[,www]
myldSel = LD(as.bed.matrix( subsnps ), lim=c(1,ncol(subsnps)) ) # expensive to compute
# pdf( "~/code/navy/PING/myldsel.pdf", width=6, height=6 )
# LD.plot( myldSel )
# dev.off()


```


comparison to RGCCA

```{r rgcca}
message("use RGCCA to compute the same type of representation")
# see the RGCCA package vignette for more information on this
library( RGCCA )
# tau parameters below correspond to inter-battery factor analysis settings
# https://cran.r-project.org/web/packages/RGCCA/vignettes/vignette_RGCCA.pdf
cca.with.rgcca = sgcca( # this initializes with SVD
  A = inmats,
  C = matrix(c(0, 1, 1, 0), 2, 2), # cca
  c1 = 1.0 - mysq,  # set to match simlr
  # tau = c( 1, 1 ), # for rgcca only
  ncomp = c( nEmbed, nEmbed ), scale = TRUE, verbose = TRUE )
wsol = cca.with.rgcca
straindf<-data.frame( bmi=numericalpheno[ train,BMINAME], G=numericalpheno[ train,"GENDER"] ,
   snpse=as.matrix( snpsf[train, ] ) %*% as.matrix( wsol$a[[1]] ) )
stestdf <-data.frame( bmi=numericalpheno[-train,BMINAME], G=numericalpheno[ -train,"GENDER"] ,
   snpse=as.matrix( snpsf[-train,] ) %*% as.matrix( wsol$a[[1]] ) )
myrf<-mlFun( bmi ~ . , data=straindf[,], localImp = TRUE )
spreddf <- predict( myrf, newdata=stestdf )
rtemis::mplot3.xy(stestdf$bmi, spreddf, fit = "lm",main=paste('Predicted vs real BMI: SGCCA'))
print( cor.test( spreddf, stestdf$bmi ) )
print(paste("RGCCA Err",  mean(abs(spreddf-stestdf$bmi))  ) )
importance_frame <- measure_importance( myrf )
plot_multi_way_importance( importance_frame, size_measure = "p_value" )
# plot_multi_way_importance( importance_frame, x_measure = "node_purity_increase",
# y_measure = "no_of_nodes", size_measure = "p_value" )
```
